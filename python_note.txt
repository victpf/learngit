DJANGO

这里，有两个必填项， subject 和 message，所以需要对这两个进行验证。 注意，我们使用
request.POST.get()方法，并提供一个空的字符串作为默认值；这个方法很好的解决了键丢失与空数据问
题。

def contact(request):
errors = []
if request.method == 'POST':
if not request.POST.get('subject', ''):
errors.append('Enter a subject.')
if not request.POST.get('message', ''):
errors.append('Enter a message.')

处理错误的输入（使用单个布尔类型和列表的区别）：
--- 1. 使用单个布尔类型：
<html>
<head>
<title>Search</title>
</head>
<body>
{% if error %}
<p style="color: red;">Please submit a search term 20 characters or shorter.</p>  --- 这样只能检测到是不是除了错误，不知道除了什么错误以及
                                                                                      针对不同的错误进行对应的处理
{% endif %}
<form action="/search/" method="get">
<input type="text" name="q">
<input type="submit" value="Search">
</form>
</body>
</html>

--- 2. 使用列表：
def search(request):
**errors = []**
if 'q' in request.GET:
q = request.GET['q']
if not q:
**errors.append('Enter a search term.')**
elif len(q) > 20:
**errors.append('Please enter at most 20 characters.')**
else:
books = Book.objects.filter(title__icontains=q)
return render_to_response('search_results.html',
{'books': books, 'query': q})
return render_to_response('search_form.html',
{**'errors': errors** })

这种情况的代码就可以处理两种错误：
  （1） 空的输入
  （2）	超过20字节的输入
  
这种情况下，模版也需要进行对应的改动：
<html>
<head>
<title>Search</title>
</head>
<body>
**{% if errors %}**
**<ul>**
**{% for error in errors %}**
**<li>{{ error }}</li>**
**{% endfor %}**
**</ul>**
**{% endif %}**
<form action="/search/" method="get">
<input type="text" name="q">
<input type="submit" value="Search">
</form>
</body>
</html>

contract 表单：
contract模版：
<html>
<head>
<title>Contact us</title>
</head>
<body>
<h1>Contact us</h1>
{% if errors %}
<ul>
{% for error in errors %}
<li>{{ error }}</li>
{% endfor %}
</ul>
{% endif %}

<form action="/contact/" method="post">
<p>Subject: <input type="text" name="subject"></p>
<p>Your e‐mail (optional): <input type="text" name="email"></p>
<p>Message: <textarea name="message" rows="10" cols="50"></textarea></p>
<input type="submit" value="Submit">

</form>
</body>
</html>



DJANGO提供的高级库：表单类：
from django import forms
class ContactForm(forms.Form):
subject = forms.CharField()
email = forms.EmailField(required=False)
message = forms.CharField()
这看上去简单易懂，并且很像在模块中使用的语法。 表单中的每一个字段（域）作为Form类的属性，被展现
成Field类。这里只用到CharField和EmailField类型。 每一个字段都默认是必填。要使email成为可选项，我
们需要指定required=False。


django的高级库里边自定义新的校验方法以及方法的使用规则：
我们希望`` message`` 字段有一个额外的校验，我们增加一个`` clean_message()`` 方法到`` Form`` 类：
from django import forms
class ContactForm(forms.Form):
subject = forms.CharField(max_length=100)
email = forms.EmailField(required=False)
message = forms.CharField(widget=forms.Textarea)
def clean_message(self):
message = self.cleaned_data['message']
num_words = len(message.split())
if num_words < 4:
raise forms.ValidationError("Not enough words!")
return message

Django的form系统自动寻找匹配的函数方法，该方法名称以clean_开头，并以字段名称结束。 如果有这样的
方法，它将在校验时被调用。
特别地，clean_message()方法将在指定字段的默认校验逻辑执行* 之后* 被调用。（本例中，在必
填CharField这个校验逻辑之后。）因为字段数据已经被部分处理，所以它被从self.cleaned_data中提取出来
了。同样，我们不必担心数据是否为空，因为它已经被校验过了。


HTML表单中自动生成的标签默认是按照规则生成的：用空格代替下划线，首字母大写。如email的标签
是"Email" 。（好像在哪听到过？ 是的，同样的逻辑被用于模块（model）中字段的verbose_name值。 我们在
第五章谈到过。）
像在模块中做过的那样，我们同样可以自定义字段的标签。 仅需使用label，像这样：
class ContactForm(forms.Form):
subject = forms.CharField(max_length=100)
email = forms.EmailField(required=False, **label='Your e‐mail address'** )
message = forms.CharField(widget=forms.Textarea)



设置初始值
让我们再改进一下这个表单：为字subject段添加* 初始值* ： "I love your site!" （一点建议，但没坏处。
）为此，我们可以在创建Form实体时，使用initial参数：
def contact(request):
if request.method == 'POST':
form = ContactForm(request.POST)
if form.is_valid():
cd = form.cleaned_data
send_mail(
cd['subject'],
cd['message'],
cd.get('email', `'noreply@example.com`_'),
[`'siteowner@example.com`_'],
)
return HttpResponseRedirect('/contact/thanks/')
else:
form = ContactForm(
**initial={'subject': 'I love your site!'}**
)
return render_to_response('contact_form.html', {'form': form})
现在，subject字段将被那个句子填充。
请注意，传入* 初始值* 数据和传入数据以* 绑定* 表单是有区别的。 最大的区别是，如果仅传入* 初始值* 数
据，表单是unbound的，那意味着它没有错误消息。

绑定之后，就会有下面的属性：
>>> f = ContactForm({'subject': 'Hello', 'message': ''})
>>> f['message'].errors
[u'This field is required.']
也就是说，errors方法可以帮助我们获取出错字段的出错原因
每一个邦定Form实体都有一个errors属性，它为你提供了一个字段与错误消息相映射的字典表。
>>> f = ContactForm({'subject': 'Hello', 'message': ''})
>>> f.errors
{'message': [u'This field is required.']}

一旦对一个form实体赋值，那么就得到了一个绑定的form:
-- 然后就可以得到
